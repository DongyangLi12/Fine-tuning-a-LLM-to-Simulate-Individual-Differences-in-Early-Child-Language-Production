# -*- coding: utf-8 -*-
"""ChildesDataPrep_Thomas

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t_GYlf_ZBuUl0bjpTF9sxaJJ9E3xA2hK
"""

import csv
import re
!pip install gdown

!gdown 1207MEYa2SJPX8bHLGBTUcnC5As41B0Pk

!unzip Thomas_A.zip -d Thomas_A

with open('Section_A_pairs_thomas_final.csv', 'r', encoding='utf-8', errors='ignore') as f:
    for i, line in enumerate(f):
        if '\x15' in line:
            print(f"Line {i}: {repr(line)}")

import sys, os, re


def recurse_dirs(dir):
    subdir = dir if dir.endswith("/") else dir + "/"
    remove_embedded_returns(subdir)
    for f in os.listdir(subdir):
        if f.endswith(".rem"):
            get_file_text(subdir + f, f)


def get_file_text(file,filename):
    previousline="START"
    cleaned_lines = []

    with open(file, 'r') as infile:
        lines = infile.readlines()
        i = 0
        for line in lines:
             i=i+1

             if not re.match(".*xxx.*",line):
               if re.match("\*(CHI|MOT|INV|FAT)\:[^\.]+\.",line.rstrip('\n')):
                    speaker = re.search("\*(CHI|MOT|INV|FAT)\:",line)[0]
                    line = deal_with_variant_form_exceptions(line)
                    line = deal_with_marked_errors_etc(line)
                    line = line.split(" ")
                    line = remove_commas(line)
                    line = deal_with_variant_forms(line)
                    line = ' '.join(line)
                    line = re.sub("[^ ]+ \[\/\] ","",line)
                    line = re.sub("[^ ]+ \[\/\/\] ","",line)
                    line = re.sub("<.*?> \[\/\/\] ","",line)
                    line = re.sub("\&-um ","",line)
                    line = re.sub("\+ ","",line)
                    # Thomas data
                    line = re.sub("<", "", line)
                    line = re.sub(">", "", line)
                    line = re.sub(r"\d+_\d+", "", line)
                    line = re.sub("\@+\w", "", line)
                    line = re.sub(r"\+(\.+|\/+)", "", line)
                    line = re.sub(r'&~\w+', '', line)
                    line = re.sub(r"&-\w+", "", line)
                    line = re.sub(r'\[!=\w+\] ', '', line)
                    line = re.sub(r'\+"', '', line)
                    line = re.sub(r'\+"/', '', line)
                    line = re.sub(r"\x15\x15", "", line)



                    if i <= len(lines) and lines[i].strip().startswith('%mor:'):
                      response  = clean_text(line.split(':',1)[1])
                      mor = clean_mor(lines[i].strip().split(':',1)[1].strip())
                      mor = re.sub("cm\|cm ","",mor)

                      response_as_list = response.split()
                      mor_tokens = mor.split()

                      new_response_as_list = []
                      j = 0

                      for mortok in mor_tokens:
                          if "~" in mortok:
                              subtoks = mortok.split("~")
                              for subtok in subtoks:
                                  wordform = re.sub(".+\\|([^\\|]+)$", "\\1", subtok)
                                  new_response_as_list.append(wordform)
                              j += 1  # consume one response token
                          else:
                              if j < len(response_as_list):
                                  new_response_as_list.append(response_as_list[j])
                                  j += 1
                      cleaned_lines.append(speaker + " ".join(new_response_as_list))

    clean_file_path = file.replace(".rem", ".clean")
    with open(clean_file_path, 'w', encoding='utf-8') as outfile:
        for cl in cleaned_lines:
            outfile.write(cl + '\n')

def remove_embedded_returns(my_dir):
    import os
    import copy
    files = os.listdir(my_dir)
    for file in files:
        if (('.cha' in file
             or '.cex' in file)
            and '.rem' not in file
                and '._' not in file):
            with open(my_dir + file, 'r') as infile:
                inlist = infile.readlines()
                for i in range(len(inlist)):
                    inlist[i] = inlist[i].split()
                    if inlist[i] == []:
                        inlist[i] = ['binthis']
                while ['binthis'] in inlist:
                    inlist.remove(['binthis'])
                for j in range(5):
                    for i in range(len(inlist)):
                        if (len(inlist[i]) > 0
                            and inlist[i][0][0] in ['%', '*', '@', '%']
                            and i < len(inlist) - 2
                            and inlist[i+1][0][0] not in ['%', '*', '@', '%']
                                and inlist[i+1] != ['binthis']):
                            inlist[i] = copy.deepcopy(
                                inlist[i]) + copy.deepcopy(inlist[i+1])
                            inlist[i+1] = ['binthis']
                        if inlist[i] == []:
                            inlist[i] = ['binthis']
                    while ['binthis'] in inlist:
                        inlist.remove(['binthis'])
            with open(my_dir + file + '.rem', 'w') as outfile:
                for line in inlist:
                    outfile.write(' '.join(line) + '\n')


def deal_with_variant_form_exceptions(textline):

    textline = textline.replace('ahem ach [: I don’t]', 'I don’t')
    textline = textline.replace('Uh no [: don’t know]', 'don’t know')
    textline = textline.replace('gonna [: going to]', 'gonna')
    textline = textline.replace('goinga [: going to]', 'gonna')
    textline = textline.replace('gon [: going to]', 'gonna')
    textline = textline.replace('deres [: there is]', 'there’s')
    textline = textline.replace('don [: do not]', 'don’t')
    textline = textline.replace('hed+up [: fed up]', 'fed up')
    textline = textline.replace('hull+up [: full up]', 'full up')
    textline = textline.replace('hasta [: has to]', 'has to')
    textline = textline.replace('hasta', 'has to')
    textline = textline.replace('hafta [: have to]', 'have to')
    textline = textline.replace('hafta', 'have to')
    textline = textline.replace('needta [: need to]', 'need to')
    textline = textline.replace('needta', 'need to')
    textline = textline.replace('wanna [: want to]', 'want to')
    textline = textline.replace('wanna', 'want to')
    textline = textline.replace(
        'creabids [: creamy porridge]', 'creamy porridge')
    textline = textline.replace('fire engine ', 'fire+engine ')
    # Thomas
    textline = textline.replace('choo_choos@f', 'choochoos')
    textline = textline.replace('wo [: what’s]', 'what’s')
    textline = textline.replace('a@p', 'a')
    textline = textline.replace('bo [: brown]', 'brown')
    textline = textline.replace('dis [: this]', 'this')
    textline = textline.replace('ah^shhh@o ', 'ahshhh')
    textline = textline.replace('bo [: boat]', 'boat')
    textline = textline.replace('dis [: this]', 'this')
    textline = textline.replace('po@c', 'red')
    textline = textline.replace('(h)as', 'has')
    textline = textline.replace('hm:', 'hm')
    return textline


def deal_with_variant_forms(textline):

    newtextline = []
    lastitem = ''
    lastbutoneitem = ''
    for item in textline:
        item = item.replace('(', '')
        item = item.replace(')', '')
        if(lastitem == '[:' and item.find(']') > 0):
            item = item.replace(']', '')
            del newtextline[-1]
            del newtextline[-1]
        elif(lastbutoneitem == '[:' and lastitem.find(']') <= 0 and item.find(']') > 0 and item.find('[') < 0):
            item = lastitem + "+" + item.replace(']', '')
            del newtextline[-1]
            del newtextline[-1]
            del newtextline[-1]

        lastbutoneitem = lastitem
        lastitem = item
        newtextline.append(item.lower())
    return newtextline

def deal_with_marked_errors_etc(textline):
    textline = textline.replace('][', '] [')
    textline = re.sub('([^\[])<', '\\1 <', textline)
    textline = re.sub('<([^\]])', '< \\1', textline)
    textline = re.sub('([^\[])>', '\\1 >', textline)
    textline = re.sub('>([^\]])', '> \\1', textline)
    textline = re.sub('([^ ]),','\\1 ,', textline)
    textline = re.sub(',([^ ])',', \\1', textline)
    textline = textline.replace('[?] ', '')
    textline = textline.replace('[*] ', '')
    textline = textline.replace('[0is *] ', '')
    textline = textline.replace('[* 0is] ', '')


    return textline

def remove_commas(textline):
    outline = []
    for item in textline:
        if item != ",":
            outline.append(item.lower())
    return outline

def clean_text(text):
    text = re.sub(r'\[.*?\]', '', text)
    text = re.sub(r" \.| \?| \,|\„|\!", '', text)
    return re.sub(r'\s+', ' ', text).strip()

def clean_mor(text):
    text = re.sub(r" \.| \?| \,", '', text)
    return text

recurse_dirs("Thomas_A")

import os
import csv

def extract_pairs_from_file(clean_file_path):
    pairs = []
    last_mot = None

    with open(clean_file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    for line in lines:
        line = line.strip()
        if line.startswith('*MOT:'):
            last_mot = line[5:].strip()
        elif line.startswith('*CHI:') and last_mot:
            chi_line = line[5:].strip()
            pairs.append([last_mot, chi_line])
            last_mot = None

    return pairs

def batch_process_to_one_csv(root_folder, output_csv='Section_A_pairs_thomas_final.csv'):
    all_rows = []

    for subdir, _, files in os.walk(root_folder):
        for file in files:
            if file.endswith('.cha.clean'):
                full_path = os.path.join(subdir, file)
                pairs = extract_pairs_from_file(full_path)
                all_rows.extend(pairs)

    with open(output_csv, 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow(['context', 'response'])
        writer.writerows(all_rows)

    print(f"Saved merged CSV: {output_csv}")

batch_process_to_one_csv('Thomas_A')

import zipfile

def zip_csv(folder, zip_filename='all_pairs.zip'):
    with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for dirpath, _, filenames in os.walk(folder):
            for file in filenames:
                if file.endswith('.csv'):
                    full_path = os.path.join(dirpath, file)
                    rel_path = os.path.relpath(full_path, folder)
                    zipf.write(full_path, arcname=rel_path)

zip_csv("Thomas/")