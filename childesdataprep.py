# -*- coding: utf-8 -*-
"""ChildesDataPrep.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wrqgm5EfnX15MCUObej0okIm8mlIbLL_
"""

import csv
import re

!gdown 1J3C3wlPJ0grveIOi1HfAuSD-VDubgkgv

!unzip Manchester.zip

recurse_dirs("Manchester/")

import sys, os, re
def recurse_dirs(dir):

    outlist = []
    corpora = os.listdir(dir)
    for corpus in corpora:
        path = dir + corpus
        dirbin = []

        for d_path, d_names, f_names in os.walk(path):

            if any(fname.endswith('.cha') for fname in os.listdir(d_path)):
                subdir = d_path + "/"
                remove_embedded_returns(subdir)
                for f in os.listdir(subdir):
                    if f.endswith('.rem'):
                        get_file_text(subdir + f,f)


def get_file_text(file,filename):
    previousline="START"
    cleaned_lines = []

    with open(file, 'r') as infile:
        lines = infile.readlines()
        i = 0
        for line in lines:
             i=i+1

             if not re.match(".*xxx.*",line):
               if re.match("\*(CHI|MOT|INV|FAT)\:[^\.]+\.",line.rstrip('\n')):
                    speaker = re.search("\*(CHI|MOT|INV|FAT)\:",line)[0]
                    line = deal_with_variant_form_exceptions(line)
                    line = deal_with_marked_errors_etc(line)
                    line = line.split(" ")
                    line = remove_commas(line)
                    line = deal_with_variant_forms(line)
                    line = ' '.join(line)
                    line = re.sub("[^ ]+ \[\/\] ","",line)
                    line = re.sub("\&-um ","",line)
                    line = re.sub("\+ ","",line)

                    if i <= len(lines) and lines[i].strip().startswith('%mor:'):
                      response  = clean_text(line.split(':',1)[1])
                      mor = clean_mor(lines[i].strip().split(':',1)[1].strip())
                      mor = re.sub("cm\|cm ","",mor)

                      response_as_list=response.split()
                      for j in range(len(mor.split())):
                                mortok = mor.split()[j]

                                if "~" in mortok:
                                   del response_as_list[j]
                                   subtoks = mortok.split("~")
                                   response_as_list.insert(j,re.sub(".+\\|([^\\|]+)$","\\1",subtoks[0]))
                                   response_as_list.insert(j+1,re.sub(".+\\|([^\\|]+)$","\\1",subtoks[1]))
                      cleaned_lines.append(speaker + " ".join(response_as_list))


    clean_file_path = file.replace(".rem", ".clean")
    with open(clean_file_path, 'w', encoding='utf-8') as outfile:
        for cl in cleaned_lines:
            outfile.write(cl + '\n')


def remove_embedded_returns(my_dir):
    import os
    import copy
    files = os.listdir(my_dir)
    for file in files:
        if (('.cha' in file
             or '.cex' in file)
            and '.rem' not in file
                and '._' not in file):
            with open(my_dir + file, 'r') as infile:
                inlist = infile.readlines()
                for i in range(len(inlist)):
                    inlist[i] = inlist[i].split()
                    if inlist[i] == []:
                        inlist[i] = ['binthis']
                while ['binthis'] in inlist:
                    inlist.remove(['binthis'])
                for j in range(5):
                    for i in range(len(inlist)):
                        if (len(inlist[i]) > 0
                            and inlist[i][0][0] in ['%', '*', '@', '%']
                            and i < len(inlist) - 2
                            and inlist[i+1][0][0] not in ['%', '*', '@', '%']
                                and inlist[i+1] != ['binthis']):
                            inlist[i] = copy.deepcopy(
                                inlist[i]) + copy.deepcopy(inlist[i+1])
                            inlist[i+1] = ['binthis']
                        if inlist[i] == []:
                            inlist[i] = ['binthis']
                    while ['binthis'] in inlist:
                        inlist.remove(['binthis'])
            with open(my_dir + file + '.rem', 'w') as outfile:
                for line in inlist:
                    outfile.write(' '.join(line) + '\n')


def deal_with_variant_form_exceptions(textline):

    textline = textline.replace('ahem ach [: I don’t]', 'I don’t')
    textline = textline.replace('Uh no [: don’t know]', 'don’t know')
    textline = textline.replace('gonna [: going to]', 'gonna')
    textline = textline.replace('goinga [: going to]', 'gonna')
    textline = textline.replace('gon [: going to]', 'gonna')
    textline = textline.replace('deres [: there is]', 'there’s')
    textline = textline.replace('don [: do not]', 'don’t')
    textline = textline.replace('hed+up [: fed up]', 'fed up')
    textline = textline.replace('hull+up [: full up]', 'full up')
    textline = textline.replace('hasta [: has to]', 'has to')
    textline = textline.replace('hasta', 'has to')
    textline = textline.replace('hafta [: have to]', 'have to')
    textline = textline.replace('hafta', 'have to')
    textline = textline.replace('needta [: need to]', 'need to')
    textline = textline.replace('needta', 'need to')
    textline = textline.replace('wanna [: want to]', 'want to')
    textline = textline.replace('wanna', 'want to')
    textline = textline.replace(
        'creabids [: creamy porridge]', 'creamy porridge')
    textline = textline.replace('fire engine ', 'fire+engine ')

    return textline


def deal_with_variant_forms(textline):

    newtextline = []
    lastitem = ''
    lastbutoneitem = ''
    for item in textline:
        item = item.replace('(', '')
        item = item.replace(')', '')
        if(lastitem == '[:' and item.find(']') > 0):
            item = item.replace(']', '')
            del newtextline[-1]
            del newtextline[-1]
        elif(lastbutoneitem == '[:' and lastitem.find(']') <= 0 and item.find(']') > 0 and item.find('[') < 0):
            item = lastitem + "+" + item.replace(']', '')
            del newtextline[-1]
            del newtextline[-1]
            del newtextline[-1]
        lastbutoneitem = lastitem
        lastitem = item
        newtextline.append(item.lower())
    return newtextline

def deal_with_marked_errors_etc(textline):
    textline = textline.replace('][', '] [')
    textline = re.sub('([^\[])<', '\\1 <', textline)
    textline = re.sub('<([^\]])', '< \\1', textline)
    textline = re.sub('([^\[])>', '\\1 >', textline)
    textline = re.sub('>([^\]])', '> \\1', textline)
    textline = re.sub('([^ ]),','\\1 ,', textline)
    textline = re.sub(',([^ ])',', \\1', textline)
    textline = textline.replace('[?] ', '')
    textline = textline.replace('[*] ', '')
    textline = textline.replace('[0is *] ', '')
    textline = textline.replace('[* 0is] ', '')
    textline = textline.replace('0is ', '')
    return textline

def remove_commas(textline):
    outline = []
    for item in textline:
        if item != ",":
            outline.append(item.lower())
    return outline

def clean_text(text):
    text = re.sub(r'\[.*?\]', '', text)
    text = re.sub(r" \.| \?| \,", '', text)
    text = re.sub(r'\(\.\)', '', text)
    return re.sub(r'\s+', ' ', text).strip()

def clean_mor(text):
    text = re.sub(r'\[.*?\]', '', text)
    text = re.sub(r" \.| \?| \,", '', text)
    return re.sub(r'\s+', ' ', text).strip()

def process_cha_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    for i, raw in enumerate(lines):
        line = raw.strip()

        if line.startswith('*MOT:'):
          if i+1 < len(lines) and lines[i+1].strip().startswith('%mor:'):
            context = clean_text(line.split(':',1)[1])
            context_mor = clean_mor(lines[i+1].split(':',1)[1])
            if len(context.split()) != len(context_mor.split()):
              print(line)
              print(lines[i+1])
              print(context + " : " + context_mor)


        elif line.startswith('*CHI:'):
            if i+1 < len(lines) and lines[i+1].strip().startswith('%mor:'):
                response  = clean_text(line.split(':',1)[1])
                child_mor = clean_mor(lines[i+1].split(':',1)[1])
                if len(response.split()) != len(child_mor.split()):
                  print(line)
                  print(lines[i+1])
                  print(response + " : " + child_mor)

def process_pair(clean_file_path):
    output_rows = []
    last_mot = None
    filename = os.path.basename(clean_file_path).replace('.cha.clean', '')

    with open(clean_file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    for i, line in enumerate(lines):
        line = line.strip()
        if line.startswith('*MOT:'):
            last_mot = line[5:].strip()
        elif line.startswith('*CHI:') and last_mot:
            chi_line = line[5:].strip()
            output_rows.append([last_mot, chi_line])
            last_mot = None
    return pairs


def batch_process_all_clean_files(root_folder):
    for subdir, _, files in os.walk(root_folder):
        for file in files:
            if file.endswith('.cha.clean'):
                full_path = os.path.join(subdir, file)
                process_pair(full_path)

batch_process_all_clean_files('Manchester/')

import zipfile

def zip_csv(folder, zip_filename='all_pairs.zip'):
    with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for dirpath, _, filenames in os.walk(folder):
            for file in filenames:
                if file.endswith('.csv'):
                    full_path = os.path.join(dirpath, file)
                    rel_path = os.path.relpath(full_path, folder)
                    zipf.write(full_path, arcname=rel_path)

zip_csv("Manchester/")